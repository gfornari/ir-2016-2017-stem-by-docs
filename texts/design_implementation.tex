\section{Software design and implementation}
    \subsection{Technologies}
        We chose to develop our project using Java. This programming language has many open source libraries and large active communities with millions of users. Moreover, programs written in Java are portable and therefore platform-independent.\par

        In order to make the management of our Java-based project easier, we chose to use Maven\footnotemark{}. This tool provides a uniform build system and guidelines for best practices development. Moreover, Maven is exceptionally good at managing external dependencies.\par

        \footnotetext{\url{https://maven.apache.org/}}
    \subsection{Design choices}
        We decided to respect a very important principle of software engineering: the design should be specific to the problem that you are facing, but also general enough for future requirements. If in the future someone will decide to use and extend the software that we developed, we want to avoid the need for a redesign.\par

        Breaking code up into modules helps to organize large code bases and makes programs easier to understand. But above all, modules are helpful for creating libraries that can be imported and used in different applications that share some functionality. We created many standalone modules that can be used and extended even outside the context of this project, as shown in Fig. \ref{stemby-package}.\par

        \begin{figure}
			\centering
			\input{./diagrams/stemby_package.tex}
            \caption{Structure of the package \code{com.stemby}}
			\label{stemby-package}
		\end{figure}

        We split the code into two main modules:
        \begin{center}
			\begin{tabular}[H]{| p{0.22\textwidth} | p{0.72\textwidth} |}
                \hline
                \code{com.stemby.commons}   & General purpose package that can be used for a variety of tasks \\ \hline
				\code{com.stemby.ir}        & Package that contains classes and interfaces closely tied to IR \\ \hline
			\end{tabular}
        \end{center}

        The \code{com.stemby.commons} package contains two subpackages:
        \begin{center}
			\begin{tabular}[H]{| p{0.36\textwidth} | p{0.58\textwidth} |}
                \hline
                \code{com.stemby.commons.util}          & Package which focuses on general data structures \\ \hline
                \code{com.stemby.commons.algorithms}    & Package that contains a collection of general algorithms on different data structures \\ \hline
			\end{tabular}
        \end{center}

        The \code{com.stemby.ir} package is designed to be extended in the future with other classes regarding Information Retrieval in general. Whithin it, we located three packages:
        \begin{center}
			\begin{tabular}[H]{| p{0.30\textwidth} | p{0.64\textwidth} |}
                \hline
                \code{com.stemby.ir.util}           & Package that contains data structures used specifically in IR \\ \hline
				\code{com.stemby.ir.io}             & Package that contains classes that support input and output \\ \hline
                \code{com.stemby.ir.algorithms}     & Package that contains algorithms to be used in IR \\ \hline
			\end{tabular}
        \end{center}

        In the future, the \code{com.stemby.ir.algorithms} package can be extended with algorithms regarding indexing, evaluation\dots{} At the moment, it just contains the \code{com.stemby.ir.algorithms.stemming} subpackage, which focuses specifically on \emph{stemming} algorithms. Whithin the \code{stemming} module there is the main part of our work: the \code{com.stemby.ir.algorithms.stemming.sns} package, whose task is to implement the SNS algorithm.\par

    \subsection{Analysis and resolution of the main problems}
        \subsubsection{Memory management}
            The first problem we faced was about the \emph{memory consumption}. In fact, if we had proceeded to the implementation of the algorithm following step by step the pseudocode provided, we would have soon realized that to deal with non-trivial collections would take an axcessive amount of memory.\\
            Example with a real co-occurrence matrix: suppose you have a collection of documents where there are 400,000 terms (as in the case of the Italian collection, which was provided to us); if we had chosen a simple array of integers we would need about \emph{600GB} of memory!\par
            The improvements we made to get a better memory management are based on two key observations:
            \begin{itemize}
                \item Firstly, we realized that arrays of co-occurrences in general are very sparse. The confirmation came after calculating the entire matrix of co-occurrences of the Russian collection: we estimated that about \(149/150\) of the matrix consists of zero elements. The algorithm then calculates an adjacency matrix: this is sparse at least as much as the co-occurrence matrix. Therefore, in general, all the matrices that we use are sparse.
                \item Secondly, we noticed that both the co-occurrences and the adjacency matrices are symmetrical.
            \end{itemize}
        \subsubsection{Efficiency}
        \subsubsection{Extensibility and usability}